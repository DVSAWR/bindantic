from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path

from pydantic import Field

from ._base_model import BindBaseModel
from .acl_block import AclBlock
from .controls_block import ControlsBlock
from .dnssec_policy_block import DnssecPolicyBlock
from .http_block import HttpBlock
from .key_block import KeyBlock, KeyStoreBlock
from .logging_block import (
    LoggingBlock,
)
from .options_block import (
    OptionsBlock,
)
from .remote_servers_block import RemoteServersBlock
from .server_block import ServerBlock
from .statistics_channels_block import StatisticsChannelsBlock
from .tls_block import TlsBlock
from .trust_anchors_block import TrustAnchorsBlock
from .view_block import ViewBlock
from .zone_block import (
    ZoneBlock,
)


@dataclass
class GeneratedFile:
    path: Path
    content: str
    type: str  # 'config', 'zone', 'key', 'dnssec'


class NamedConfig(BindBaseModel):
    """
    Complete BIND9 configuration (named.conf).

    NOTE: This file was automatically generated by bindantic, please adjust.
    """

    acl_blocks: list[AclBlock] = Field(default_factory=list, description="Access Control Lists")
    key_blocks: list[KeyBlock] = Field(default_factory=list, description="TSIG key definitions")
    key_store_blocks: list[KeyStoreBlock] = Field(
        default_factory=list, description="DNSSEC key stores"
    )
    tls_blocks: list[TlsBlock] = Field(default_factory=list, description="TLS configurations")
    trust_anchors_blocks: list[TrustAnchorsBlock] = Field(
        default_factory=list, description="DNSSEC trust anchors"
    )
    dnssec_policy_blocks: list[DnssecPolicyBlock] = Field(
        default_factory=list, description="DNSSEC policies"
    )
    controls_block: ControlsBlock | None = Field(default=None, description="Control channels")
    statistics_channels_blocks: list[StatisticsChannelsBlock] = Field(
        default_factory=list, description="Statistics channels"
    )
    server_blocks: list[ServerBlock] = Field(
        default_factory=list, description="Server-specific settings"
    )
    remote_servers_blocks: list[RemoteServersBlock] = Field(
        default_factory=list, description="Remote servers lists"
    )
    http_blocks: list[HttpBlock] = Field(default_factory=list, description="HTTP configurations")
    options_block: OptionsBlock | None = Field(default=None, description="Global options")
    logging_block: LoggingBlock | None = Field(default=None, description="Logging configuration")
    view_blocks: list[ViewBlock] = Field(default_factory=list, description="View definitions")
    zone_blocks: list[ZoneBlock] = Field(default_factory=list, description="Zone definitions")

    def model_bind_syntax(self, indent_level: int = 0) -> str:  # noqa: PLR0912, PLR0915
        """Generate complete BIND9 configuration in one named.conf file style."""
        lines: list[str] = []

        if self.acl_blocks:
            for acl in sorted(self.acl_blocks):
                lines.append(acl.model_bind_syntax(indent_level))
                lines.append("")

        if self.key_blocks or self.key_store_blocks or self.tls_blocks:
            for key in sorted(self.key_blocks):
                lines.append(key.model_bind_syntax(indent_level))
            if self.key_blocks:
                lines.append("")

            for key_store in sorted(self.key_store_blocks):
                lines.append(key_store.model_bind_syntax(indent_level))
            if self.key_store_blocks:
                lines.append("")

            for tls in sorted(self.tls_blocks):
                lines.append(tls.model_bind_syntax(indent_level))
            if self.tls_blocks:
                lines.append("")

        if self.controls_block:
            lines.append(self.controls_block.model_bind_syntax(indent_level))
            lines.append("")

        if self.server_blocks:
            for server in sorted(self.server_blocks):
                lines.append(server.model_bind_syntax(indent_level))
            lines.append("")

        if self.trust_anchors_blocks or self.dnssec_policy_blocks:
            for ta in self.trust_anchors_blocks:
                lines.append(ta.model_bind_syntax(indent_level))
            if self.trust_anchors_blocks:
                lines.append("")

            for policy in self.dnssec_policy_blocks:
                lines.append(policy.model_bind_syntax(indent_level))
            if self.dnssec_policy_blocks:
                lines.append("")

        if self.remote_servers_blocks:
            for rs in sorted(self.remote_servers_blocks):
                lines.append(rs.model_bind_syntax(indent_level))
            lines.append("")

        if self.http_blocks:
            for http in sorted(self.http_blocks):
                lines.append(http.model_bind_syntax(indent_level))
            lines.append("")

        if self.statistics_channels_blocks:
            for stats in sorted(self.statistics_channels_blocks):
                lines.append(stats.model_bind_syntax(indent_level))
            lines.append("")

        if self.options_block:
            lines.append(self.options_block.model_bind_syntax(indent_level))
            lines.append("")

        if self.logging_block:
            lines.append(self.logging_block.model_bind_syntax(indent_level))
            lines.append("")

        if self.view_blocks:
            for view in sorted(self.view_blocks):
                lines.append(view.model_bind_syntax(indent_level))
                lines.append("")
        elif self.zone_blocks:
            for zone in sorted(self.zone_blocks):
                lines.append(zone.model_bind_syntax(indent_level))
                lines.append("")

        while lines and lines[-1] == "":
            lines.pop()
        return "\n".join(lines)

    def generate_files(self, base_dir: str | None = None) -> list[GeneratedFile]:
        """
        Generate all configuration files without writing them to disk.
        Returns a list of GeneratedFile objects with path and content.
        """
        generated_files: list[GeneratedFile] = []

        if base_dir:
            base_path = Path(base_dir)
        elif self.options_block and self.options_block.directory:
            base_path = Path(self.options_block.directory.strip('"'))
        else:
            base_path = Path.cwd()

        directories = self._get_directories(base_path)

        zone_files = self._generate_zone_files(directories)
        generated_files.extend(zone_files)

        key_files = self._generate_key_files(directories)
        generated_files.extend(key_files)

        dnssec_files = self._generate_dnssec_files(directories)
        generated_files.extend(dnssec_files)

        main_config = self._generate_main_config(directories, zone_files, key_files, dnssec_files)
        generated_files.append(main_config)

        return generated_files

    def write_files(self, base_dir: str | None = None) -> list[GeneratedFile]:
        """
        Generate and write all configuration files to disk.
        Returns a list of GeneratedFile objects with path and content.
        """
        generated_files = self.generate_files(base_dir)
        self._write_files(generated_files)
        return generated_files

    def _get_directories(self, base_path: Path) -> dict[str, Path]:
        """Get directories for file generation, ALWAYS using base_path as the root."""
        directories = {
            "base": base_path,
        }

        directories["zones"] = base_path / "zones"
        directories["keys"] = base_path / "keys"
        directories["dnssec"] = base_path / "dnssec"

        if self.options_block:
            if self.options_block.key_directory:
                key_dir = Path(self.options_block.key_directory.strip('"'))
                if key_dir.is_absolute():
                    directories["keys"] = base_path / key_dir.name
                else:
                    directories["keys"] = base_path / key_dir

            if (
                hasattr(self.options_block, "managed_keys_directory")
                and self.options_block.managed_keys_directory
            ):
                dnssec_dir = Path(self.options_block.managed_keys_directory.strip('"'))
                if dnssec_dir.is_absolute():
                    directories["dnssec"] = base_path / dnssec_dir.name
                else:
                    directories["dnssec"] = base_path / dnssec_dir

        return directories

    def _generate_zone_files(self, directories: dict[str, Path]) -> list[GeneratedFile]:
        zone_files: list[GeneratedFile] = []
        zones_to_process: list[ZoneBlock] = []

        if self.view_blocks:
            for view in self.view_blocks:
                if view.view_zones:
                    zones_to_process.extend(view.view_zones)
        else:
            zones_to_process.extend(self.zone_blocks)

        processed_zones = set()

        for zone in zones_to_process:
            zone_id = zone.name
            if zone_id in processed_zones:
                continue

            processed_zones.add(zone_id)

            if zone.zone_type.value == "primary" and zone.resource_records:
                if zone.file:
                    zone_path = Path(zone.file.strip('"'))
                    if zone_path.is_absolute():
                        zone_file_path = directories["zones"] / zone_path.name
                    else:
                        zone_file_path = directories["base"] / zone_path

                    rel_path = zone_file_path.relative_to(directories["base"])
                    zone.file = f'"{rel_path}"'
                else:
                    safe_name = zone.name.rstrip(".").replace(".", "_")
                    zone_file_path = directories["zones"] / f"{safe_name}.zone"
                    zone.file = f'"{zone_file_path.relative_to(directories["base"])}"'

                try:
                    zone_content = zone.model_bind_syntax_zone_file()
                    zone_files.append(
                        GeneratedFile(path=zone_file_path, content=zone_content, type="zone")
                    )
                except ValueError as exc:
                    raise ValueError(
                        f"Warning: Could not generate zone file for {zone.name}"
                    ) from exc

        return zone_files

    def _generate_key_files(self, directories: dict[str, Path]) -> list[GeneratedFile]:
        key_files: list[GeneratedFile] = []

        if self.key_blocks:
            key_file_path = directories["keys"] / "tsig-keys.conf"
            key_content = []

            for key in sorted(self.key_blocks):
                key_content.append(key.model_bind_syntax())
                key_content.append("")

            if key_content and key_content[-1] == "":
                key_content.pop()

            if key_content:
                key_files.append(
                    GeneratedFile(path=key_file_path, content="\n".join(key_content), type="key")
                )

        if self.key_store_blocks:
            key_store_file_path = directories["keys"] / "key-stores.conf"
            key_store_content = []

            for key_store in sorted(self.key_store_blocks):
                key_store_content.append(key_store.model_bind_syntax())
                key_store_content.append("")

            if key_store_content and key_store_content[-1] == "":
                key_store_content.pop()

            if key_store_content:
                key_files.append(
                    GeneratedFile(
                        path=key_store_file_path,
                        content="\n".join(key_store_content),
                        type="key_store",
                    )
                )

        return key_files

    def _generate_dnssec_files(self, directories: dict[str, Path]) -> list[GeneratedFile]:
        dnssec_files: list[GeneratedFile] = []

        if self.trust_anchors_blocks:
            trust_anchors_file_path = directories["dnssec"] / "trust-anchors.conf"
            trust_anchors_content = []

            for ta in self.trust_anchors_blocks:
                trust_anchors_content.append(ta.model_bind_syntax())
                trust_anchors_content.append("")

            if trust_anchors_content and trust_anchors_content[-1] == "":
                trust_anchors_content.pop()

            if trust_anchors_content:
                dnssec_files.append(
                    GeneratedFile(
                        path=trust_anchors_file_path,
                        content="\n".join(trust_anchors_content),
                        type="dnssec",
                    )
                )

        if self.dnssec_policy_blocks:
            dnssec_policy_file_path = directories["dnssec"] / "dnssec-policies.conf"
            dnssec_policy_content = []

            for policy in self.dnssec_policy_blocks:
                dnssec_policy_content.append(policy.model_bind_syntax())
                dnssec_policy_content.append("")

            if dnssec_policy_content and dnssec_policy_content[-1] == "":
                dnssec_policy_content.pop()

            if dnssec_policy_content:
                dnssec_files.append(
                    GeneratedFile(
                        path=dnssec_policy_file_path,
                        content="\n".join(dnssec_policy_content),
                        type="dnssec",
                    )
                )

        return dnssec_files

    def _generate_main_config(
        self,
        directories: dict[str, Path],
        zone_files: list[GeneratedFile],
        key_files: list[GeneratedFile],
        dnssec_files: list[GeneratedFile],
    ) -> GeneratedFile:
        main_config_path = directories["base"] / "named.conf"
        lines: list[str] = []

        lines.extend(
            [
                "# Automatically generated by bindantic - please adjust!",
                "",
            ]
        )

        if key_files:
            for key_file in key_files:
                try:
                    rel_path = key_file.path.relative_to(directories["base"])
                    lines.append(f'include "{rel_path}";')
                except ValueError:
                    lines.append(f'include "{key_file.path}";')
            lines.append("")

        if dnssec_files:
            for dnssec_file in dnssec_files:
                try:
                    rel_path = dnssec_file.path.relative_to(directories["base"])
                    lines.append(f'include "{rel_path}";')
                except ValueError:
                    lines.append(f'include "{dnssec_file.path}";')
            lines.append("")

        temp_config = self.model_copy(deep=True)

        temp_config.key_blocks = []
        temp_config.key_store_blocks = []
        temp_config.trust_anchors_blocks = []
        temp_config.dnssec_policy_blocks = []

        if temp_config.options_block:
            temp_config.options_block.directory = f'"{directories["base"]}"'

            if temp_config.options_block.key_directory:
                key_dir = Path(temp_config.options_block.key_directory.strip('"'))
                if key_dir.is_absolute():
                    temp_config.options_block.key_directory = f'"{key_dir.name}"'

            if (
                hasattr(temp_config.options_block, "managed_keys_directory")
                and temp_config.options_block.managed_keys_directory
            ):
                dnssec_dir = Path(temp_config.options_block.managed_keys_directory.strip('"'))
                if dnssec_dir.is_absolute():
                    temp_config.options_block.managed_keys_directory = f'"{dnssec_dir.name}"'

        config_content = temp_config.model_bind_syntax()
        lines.append(config_content)

        return GeneratedFile(path=main_config_path, content="\n".join(lines), type="config")

    def _write_files(self, generated_files: list[GeneratedFile]) -> None:
        """Write generated files to disk."""
        for file in generated_files:
            file.path.parent.mkdir(parents=True, exist_ok=True)
            with open(file.path, "w", encoding="utf-8") as f:
                f.write(file.content)
